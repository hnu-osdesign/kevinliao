# 操作系统笔记

## 分页和分段

### 分段

段寄存器由CPU自动选择，具体取决于存储器访问的类型：对于获取指令，使用代码段CS，对于堆栈操作（push/pop），使用堆栈段SS。其他指令使用数据段DS或额外段ES。后来增加了两个额外的段寄存器FS和GS，可以自由使用。  
x86的64位模式甚至不再支持分段。 而是使用分页，这完全避免了碎片问题。

### 分页

我们看到每个程序实例都有自己的页表。 指向当前活跃的页表的指针存储在特殊CPU寄存器中。 在x86上，该寄存器称为CR3。 在运行每个程序实例之前，操作系统要将指向正确页表的指针加载到该寄存器。 
![](https://github.com/hnu-osdesign/kevinliao/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/1.svg)

### 多级页表

多级页表的作用：节省页表在内存中的大小。

###  x86_64下的分页  

x86_64体系结构使用4级页表，页面大小为4KiB。 每个页表，**无论是哪级页表，具有固定大小512个条目**。 **每个条目的大小为8个字节**，因此每个页表大小都为512 * 8B = 4KiB大，恰好能装入一个页面。

![](2.svg)  
即使48到64位不被使用，也不能将它们设置为任意值。 相反，**此范围内的所有位必须是第47位的副本**，以保持地址的唯一性，并允许未来的扩展，如5级页表。 这称为符号扩展，因为它与二进制补码中的符号扩展非常相似。 如果地址未正确进行符号扩展，则CPU会抛出异常。  
每个页表条目指向下一级表的物理帧。 然后，1级页表的条目指向映射到的帧。 请注意，**页表中的所有地址都是物理的而不是虚拟的**，否则CPU也需要转换这些地址，导致永无止境的递归。每个地址空间中通常存在多个每个级别页表的实例。 最多，有：

- 一个4级页表
- 512个3级页表（因为4级页表有512个条目）
- 512*512个2级页表（因为512个3级页表中的每一个都有512个条目）
- 512 * 512 * 512个1级页表（每个2级页表512个条目）  

每个条目都是8字节（64位）大，具有以下格式：

| Bit(s) | Name                  | Meaning                                                      |
| ------ | --------------------- | ------------------------------------------------------------ |
| 0      | present               | 这个页面是否正在内存中                                       |
| 1      | writable              | 这个页面是否可写                                             |
| 2      | user accessible       | 这个页面是否可以被用户态访问                                 |
| 3      | write through caching | 对这个页面的写入是否直接进入内存（不经过cache）              |
| 4      | disable cache         | 是否完全禁止使用cache                                        |
| 5      | accessed              | 当这个页面正在被使用时，这个位会被CPU自动设置                |
| 6      | dirty                 | 当这个页面有被写入时，CPU会自动被CPU设置                     |
| 7      | huge page/null        | 在 1级和4级页表中必须为0，在3级页表中会创建1GiB的内存页，在2级页表中会创建2MiB的内存页 |
| 8      | global                | 地址空间切换时，页面不会被换出cache ( CR4 中的PGE 位必须被设置) |
| 9-11   | available             | OS可以随意使用                                               |
| 12-51  | physical address      | 物理帧地址或下一个页表的地址                                 |
| 52-62  | available             | OS可以随意使用                                               |
| 63     | no execute            | 禁止将这个页面上的数据当作代码执行 (EFER寄存器中的NXE位必须被设置) |

### TLB

与其他CPU缓存不同，TLB不是完全透明的，并且在页表的内容发生更改时不会更新或删除缓存的转换规则。这意味着**内核必须在修改页表时手动更新TLB**。为此，有一个名为`invlpg`的特殊CPU指令（“invalidate page”），用于从TLB中删除指定页面的转换规则，下次访问时这个转换规则将从页表中从新加载。通过重新设置CR3寄存器，假装进行一次地址空间转换，也可以完全刷新TLB。 rust`x86_64` crate在tlb模块中提供了实现这两个功能的Rust函数。  

